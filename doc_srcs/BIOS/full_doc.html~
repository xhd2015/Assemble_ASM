<!DOCTYPE html>
<html>
  <head>
    <title>BIOS Helpful</title>
    <script>
      /*<fulton>
	page_num=1
      </fulton> */
    </script>
  </head>
  <body>

  </body>
  <!--brief description-->
  <header>
    <p>
      This page is mainly divided into ${page_num} parts.They are: <br/>
      Programming Under BIOS
      Use DOS as a Utility
      
    </p>
  </header>
  <header>
    <h3>All References</h3>
    <ul>
      <hr/>
      <h2>BIOS</h2>
      <li><a href="http://superuser.com/questions/336021/is-bios-read-from-the-bios-chip-or-copied-into-ram-in-startup">Where Is BIOS Read from?</a></li>
      <li><a href="https://www.freebsd.org/doc/en/books/arch-handbook/boot-bios.html">BIOS boot up</a></li>
      <li><a href="http://www.uruk.org/orig-grub/mem64mb.html">BIOS Programming</a></li>
      <li><a href="http://savage.net.au/Ron/html/hex-ram-tutorial.html">A Memory Address Map</a></li>
      <li><a href="http://stackoverflow.com/questions/3274014/0xffff0-and-the-bios">A Stackoverflow Question about BIOS</a></li>
      <li><a href="http://flint.cs.yale.edu/feng/cos/resources/BIOS/">Very Detailed Info about BIOS start-up,but not including the IDT setup</a></li>
      <li><a href="http://www.bioscentral.com/">Most Detailed BIOS Info,for Experts </a></li>
      <li><a href="http://www.bioscentral.com">A Proof:IDT is setup during POST with BIOS running Time</a></li>
      <li><a href="http://help.fdos.org/en/hhstndrd/base/debug.htm">Debug in Freedos</a></li>
      <li><a href="http://www.zhihu.com/question/19573226">A Comprehensive Illustration on What Is x86</a></li>

      <hr/>
      <h2>DOS</h2>

    </ul>
  </header>
  <section id="1_bios">
    <h2>Programming Under BIOS</h2>
    <h4>Prequsites Knowledge</h4>
    How is first BIOS program started?
    What does BIOS do once started?
    How to write and run a program with BIOS?
    <a href="http://www.cnblogs.com/motadou/archive/2009/01/16/1376717.html">The constructure of IDT</a>.It shows that every 4-byte in IDTconsists of the former 2-byte for IP,and the latter 2-byte for CS.
    The BIOS source code interpreter
    <a href="http://blog.csdn.net/mzwang123/article/details/7325363">The IO Map of x86</a>
    Some Examples
    
  </section>
  <section id="2_dos">
    <h2>Use Dos as a Utility</h2>
    <ul>
      <li>
	<h4>Basic Knowledge about DOS</h4>
      </li>
      <li>
	Dos is started after loaded into 0x7c00
      </li>
      <li>
	<h4>How to write a .com(binary) file for DOS?</h4>
	<p>
	  Take linux for example,after installing qemu as an emulator,and can boot into a DOS(Freedos) system,we've already have a DOS environment to run .com.Next step is to write .com files.We have two choices , use GNU as or use DOS itself.
	  Use GNU as:<a href=""></a>
	  .code16
	  .global _start
	  ...
	  movw %cs,%ax
	  movw %ax,%ds
	  movw %ax,%ss
	  movw $stack,%ax
	  movw %ax,%sp   /*set ds,ss,sp manufacturely*/
	  ...
	  
	  .org 0x100
	  stack:

	  
	  commands:
	  $ as --32 $F.s -o $F.o  #use 32 to generate 16 bit codes
	  $ld -Ttext 0x100 -m elf_i386 $F.o -o $F.elf#.com will be loaded into 0x100
	  $objcopy -j .text -O binary $F.elf $F.com  #generate a pure binary file
	  #afterwards you can use 'objdump -d -m i8086 $F.elf' to disassemble a file,use 'objdump -d -b binary -m i8086 $F.com' to disassemble a binary file,use 'readelf -S $F.elf' to view headers
	</p>
      </li>
      <li>
	<h4> The standard constructure of .com</h4>
	<p>
	  1.just one section
	  2.no headers
	  3.it contains only binary code
	  when DOS loads .com,it
	  1.building up a prefix of segment PSP,whose length is 0x100
	  2.place int 20h to PSP:0
	  3.place the real code after PSP,e.g starting with 0x100
	</p>
      </li>
      <li>
	<h4>The standard constructure of .exe</h4>
	<p>
	  (this demostrates the file that generated by link under DOS)
	</p>
      </li>
      
      <li>
	<h4>DOS commands references</h4>
	<ul>
	  <li><h6>int 0x20</h6>
	    point cs to PSP,ip to 0.then ret.That is
	    push %ds
	    xor ax,ax
	    push ax
	    ret == int 0x20
	    or use
	    mov $0x4c00,%ax
	    int 0x21h
	  </li>
	  
	  <li>
	    <h6>Debug:
	      <a href="http://wenku.baidu.com/view/b3741f2ded630b1c59eeb59a.html">A Guide to Debug</a></h6>
	    <p>
	      If start DEBUG with no program specified,then
	      1.CS,DS,SS,ES will be set to point the next segment after DEBUG itself.
	      2.IP is set to 0x100
	      3.SP is set to either the end of the segment,or the end of address where COMMAND.com is.
	      4.other general registers are set to 0
	      If start DEBUG with a program,then
	      1.DS and ES are automatically set to PSP
	      2.BX and CX has the length of the whole program
	      
	      
	      E modify memory
	      -E ds:100 2f'sdf'8d  -- 2f 's 'd 'f 8d
	      -E ds:100
	      -[prompt to modify]
	      
	      N load file into CS:5C CS:6C,which will be used later by L/W
	      -N setcur.com

	      L load program or sector
	      -L 100 (by N)
	      -L 100 0 0 1 ( 0 0 1 is the first sector of disk,e.g. MBR)
	      m memory move
	      -m 100 L10 L110

	      S search memory
	      -S 100 L70 'j'

	      W write memory to sector
	      -w 100 0 0 1 (write mbr)
	      
	      C compare two trunck of memory(prefix L means length)
	      -c 10d L20d 21d
	      I/O in or out
	      -i 70
	      
	      H hex add/sub
	      -h 44 55
	      
	      G run to breakpoint
	      -g 1 2 3 4 ( break at 1 2 3 4)
	      
	      D dump memory
	      -d 100,200
	      
	      F fill address with given bytes
	      -F ss:0 5 F3'BD'4D2045 (if the length of list exceeds the number given,then the remainder of the list is ignored)

	      RF modify flag registers
	      -rf
	      
	      
	      
	      T next step

	      A assemble at here(If you want to use decimal,use D as suffix,such as 10d)
	      -A 0

	      U un/dis-assemble at here
	      -u 10 20
	      
	      
	      
	      P enter interuption
	      
	      
	      Examples:
	      1.Cancle BIOS password checking
	      -o 70 10
	      -o 71 11
	      
	    </p>
	  </li>
	  
  </section>
  <section id="3_qemu">
  </section>
  <section id="4_bochs">
  </section>
  
  <section id="5_as">
    <h2>Writing 16-bit Code Useing As</h2>
    as do support wirting 16-bit code that could run under real mode or 16-bit protected mode.Just put a '.code16' or '.code16gcc' in front of your codes.
    Respectively,".code32" and ".code64" to write 32- and 64- bit code.
    .code16gcc is provided to support gcc generated code.Where it differs from .code16 are,'call ret enter leave push pop pusha popa pushf popf' default to operate 32-bit size.This can uniform the use of stack.
    .arch CPU_TYPE may tell as which architecture to code to.Options are:'i8086 ix86(x=1~6) pentiumX(X=nil,pro,ii,iii,4) corei7...'
    .arch i8086,nojumps  will disable any promotion for jump.
    But after a test,the as on my machine does not support .arch i8086 or I used it in a wrong way?
    addr16/data16 and addr32/data32 will change a 16 or 32 bit operand into 32 or 16 bit.It cannot change an operand that has the same length.Example 'addr32 jmpl *(%ebx)'
    in the really 16 bit mode,you cannot use
    4(%sp)  ,  because %sp cannot be used as a base address register.Here I'll list some constraints in real mode.
    leave/enter is not used
    the first address must be executeable,e.g you can't place data in the first line.(0x100).If you insist on doing this,use ld -Ttext=0x0fe,but this just work on coverage,will not affect the dos loader's manner to always load the start of text into 0x100,no matter what you assigned to text,you can even set it to 0x0
    # It seems that I had a very shallow understanding about the writing-time/as address adn the link/ld time  address.All address inside their own segment was considered from text 0,data 0;and as will consider or not all segment's base is zero,it can leave this part of work to ld.When ld starts to work,it will collect every the same type of segment,to concatenate them,and rearrange the base of them.The -Ttext 0x01 means to add every reloc symbol this offset.
    # This experience of debugging will give a lesson , to uniform with the standard is such an important thing
    <a href="http://ce.kashanu.ac.ir/sabaghian/assembly/8086%20tutorial/8086%20instructions.htm">Here</a> is a 8086 assembly language reference
    [PUSH]
    PUSH REG
    PUSH SREG
    PUSH memory
    PUSH immediate  #--->reported issue,as does something wrong with push $x in .code16,but the same thing find in .code32
  [POP]
  POP REG
  POP SREG
  POP memory

  PUSH and POP work with 16 bit values only!
  Note: PUSH immediate works only on 80186 CPU and later!
  For COM files stack segment is generally the code segment, and stack pointer is set to value of 0FFFEh. At the address SS:0FFFEh stored a return address for RET instruction that is executed in the end of the program. 

  
  sometimes %bp is used to refer to an address , rather than the normal use of bp.
  Under this case , you must save %bp's value at first
  
  What is difference between 8086 and 80386 in real mode?The answer is NO.You can still write code that completely fine in 8086 in 80386.But in real mode , 80386 also provide some features , like that you can use %esp instead of %sp,and use it as base address register.
  But in my opinion,use 386 with real mode does nothing good.I'd like a pure real mode.However , for system that runs in real mode under 386,it may be helpful to use that.Anyway,just go ahead.
  #When use pure 16-bit mode , all suffix to indicate word length can be removed.This is not applied to 32-bit
</section>
<section id="6_i8086">
  <h2>The Instructions of i8086(16-bit),i80268 and i80386(32-bit)</h2>
  Originally, Dos runs under Real Mode.To run the dos programs under Protected Mode, you must switch to Virtual 8086 Mode.
  Under Real Mode, all instructions are considered with Privilige 0.Every instruction can be ran,including reading/writing CR0 or so, set LDTR, GDTR, IDTR, TR  and so.If the processor is i386,when  set CR0(0),PE=1,the protected mode is started.
  The real mode doesn't support multitasking, all instructions are executed under the same context.(The real mode doesn't only mean 8086)
  The handling routine for interruption is the same with 8086 under real mode.The IDT starts from 0:0,and ends with maxium length 1024.(max items=256).
  Also some extra advantages when runnig 386 as real mode.
  1.The 32-bit registers can be used.
  2.FS,GS can be used.
  3.Maybe an offset exceeding 64KB upto 4GB can be used.
  Concludingly, under real mode, you can do anything you can, DOS cannot prevent you from doing that.You can override a code segment, you can modify other program's data in the memory.
  [i8086]
  instructions:
  CLI  --  ommit the interruption
  STI
  mov -- reg and reg is invalid , cs can't be assign by this way
  --pay attention, mov ax,SEG/OFFSET ADDR are not pure asm instructions.SEG and OFFSET is used by MASM.
  push -- in 8086,immediate number cannot be push
  pop
  xchg
  in -- from src to ax
  out -- such as 'out 20h,ax'
  xlat -- query the table , not usually used
  lea
  lds -- lds si,mem(=0x77665544) then ds=0x7766,si=5544
  les
  pushf -- push flags (16-bit)
  popf
  lahf -- mov ah,flags(8~0)
  sahf -- mov flags(8~0),ah
  inc
  dec
  neg
  add
  adc  -- add with carry,adc ax,35-->ax=ax+35+cf
  sub
  sbb -- sub with carry , sub ax,35-->ax=ax-35-cf
  cmp
  not
  and
  test
  or
  xor
  int/call/ret/iret
  movs,movs[bwd]
  lods,lods[bwd]
  cmps,cmps[bwd]
  scas,scas[bwd]
  
  registers:
  cs,ds,ss,es
  FLAGS=16-bit
  [i80286]
  pusha -- push ax,cx,dx,bx,sp,bp,si,di
  popa
  ins
  outs

  [i80386]
  instructions:
  movzx,movsx -- this instruction is provided by 386 only
  pushad -- push eax~edi
  popad
  lgs
  lss
  pushfd
  popfd
  
  use ESP instead of SP in real mode
  but cannot use EIP instead of IP in real mode
  
  registers:(+)
  fs,gs
  EFLAGS=32-bit

  [some concepts]
  A program is said to be relocateable if it can be placed in any position of the RAM with modification.
  No matter which processor you are using,no matter how big your computer memory is,if you are under real mode,you can only address upto 1MB.And the offset of a segment cannot exceed 64KB.
  1000:1F00, 11F0:0000, 1100:0F00, 1080:1700 are all the same address.The calculation method is to add a '0' at right-most end of segment address,then add it with the offset.
  Dos is a single-tasking operating system.
  MS-Dos can only address upto 640KB,not 1MB.All dos also confines to that limit.This is called 640KB-limitation.The map of memory under DOS is:
  00000-003FF:IDT (1KB)
  00400-004FF:BIOS data(256B)
  00500-9FFFF:DOS and programs' area (654079B=638KB-->640KB)
  A0000-BFFFF:Video Buffer (128KB)
  C0000-FFFFF:JMP & POST code (156KB)
  #Or used by hardware,like BIOS ROM, Video Buffer, Net card(384KB)
  Particularly,when the system starts up,it firstly let cs=F000,IP=FFF0,the first instruction of BIOS ROM is JMP F000:E05B(intialization BIOS program)
  Linus firstly write linux in 1991,Finland, under 80386.
  80286 has an addressing wire named A20.It can make FFFF:3000 valid for the address(=102FF0).To enable this feature,A20 must be set to 1.(This technology is called HMA).
</section>
<section id="7_bochs">
  <h2>Using Bochs under Linux</h2>
  <ul>
    <li>
      <h4>The First Stuff : Download Bochs & Compile & Install & Run Test</h4>
      <p>
	You can download the newest version of bochs <a href="http://bochs.sourceforge.net">HERE</a>
	After downloading it, you can extract it anywhere ,then 'cd to that dir, and run './configure,after a while,run 'make install.Those are very simple tasks to install a software into your linux system.But few special ARGS need to sent to './configure to use it's full functions.On my computer, I run in the next steps:
	(I download & extract it into "~/Downloads/bochs-2.6.8")
	$ ARGS="--prefix=/usr/local --exec-prefix=$HOME/installed/bochs-dep --prefix=$HOME/installed/bochs-inst --enable-x86-64 --enable-cpp --enable-debugger --enable-disasm --enable-debugger-gui  --enable-readline --enable-x86-debugger --enable-e1000  --enable-cdrom"
	$ echo $ARGS > configuration
	$ eval sudo ./configure $ARGS
	$ make install
	$ #now I get the eorr message , it seems that ./misc/bximage.cc dose not has a make rule.Actually, this needs to fix by modifying all .cc files into .cpp
	$ #so I replaced all .cc in Makefile with .cpp
	$ make install
	$ #bochs is normally installed into my system
	$ cd ~/installed/bochs-dep/bin
	$ ./bochs ...  # stuff of things you are img to load
      </p>
    </li>
    <li>
      <h4>Configure Bochs</h4>
      <p>
	Configuring Bochs means exactly to edit the 'bochsrc' file.
	<ul>
	  <li>
	    <h6>megs</h6>
	    <p>
	      Description : the most Memory the virtual machine can have
	    </p>
	    
	  </li>
	  <li>
	    <h6>romimage</h6>
	    <p>
	      Description : set main BIOS Rom image
	      Example :
	      romimage: file=../BIOS-Bochs-lastest, address=0xffff0000 (this is the default value)
	    </p>
	  </li>
	  <li>
	    <h6>vgaromimage</h6>
	    <p>
	      Description : the VGA rom file, a buffer in the linear address
	      Example :
	      vgaromimage: file=../VGABIOS-lgpl-lastest
	    </p>
	    
	  </li>
	  
	  
	  <li>
	    <h6>floppyx</h6>
	    <p>
	      floppya:2_88=test.img, status=inserted
	      floppyb:1_44=x.img, status=inserted
	    </p>
	  </li>
	  <li>
	    <h6>boot : disk (hard disk) | cdrom | floppy </h6>
	    <p>
	    </p>
	  </li>
	  <li>
	    <h6>log : LOG.txt</h6>
	    <p>
	    </p>
	  </li>
	  <li>
	    <h6>mouse : enabled = 0 | 1</h6>
	    <p>
	      You can change this after starting up the virtual machine
	    </p>
	  </li>
	  <li>
	    <h6>ata0</h6>
	    <p>
	      Description : use the hard disk img either from other sources or generated by 'bximage'
	      Example :
	      ata0:enabled=1, ioaddr=0x1f0, ioaddr2=0x3f0, irq=14
	      ata0-master:type=disk, path=dos.img, cylinders=306, heads=4, spt-17
	      ata0-slave: type=cdrom, path=x.iso, status=inserted

	    </p>
	  </li>
	  <li>
	    <h6>display_library:X</h6>
	    <p>
	      Description : set the VGA screen
	      Example :
	      display_library: x, options="fullscreen"
	      #the first argument is [x|win32|sdl|term...],in which term means text only,use curses/ncurses library
	      #the options is [gui_debug|hideIPS|nokeyrepeat]
	      
	    </p>
	    
	  </li>
	  <li>
	    <h6>Others</h6>
	    <p>
	      There are still much more options.They can be referenced at the next topic's reference.
	    </p>
	    
	  </li>
	  
	  

	</ul>
      </p>
    </li>
    
    <li>
      <h4>Debug Using Bochs</h4>
      <p>
	Main reference is <a href="http://www.cnblogs.com/hongzg1982/articles/2116643.html">HERE</a>
	The authoritive reference is <a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">HERE</a>
      </p>
      <ul>
	<li>
	  <h6>help [command]</h6>
	  <p>
	    Example : help 'vbreak'
	  </p>
	</li>
	<li>
	  <h6>vb seg:addr</h6>
	  <p>
	    Description : break at virtual address
	    Abbrevation : vbreak
	    Example:
	  </p>
	</li>
	<li>
	  <h6>d N</h6>
	  <p>
	    Description : delete a break point
	    Abbrevation : del delete
	  </p>
	</li>
	
	<li>
	  <h6>c</h6>
	  Also as 'continue'
	  
	</li>
	<li>
	  <h6>u /LEN ADDR</h6>
	  <p>unassemble the code,like dos debug does
	  </p>
	</li>
	<li>
	  <h6>disassemble</h6>
	  <p>
	    Description : The disassembly related command
	    Example :
	    disassemble start end
	    disassemble swithc-mode #show AT&amp;T or Intel syntax 
	    set $auto_disassemble = n #show how many instructions every time at a break point
	    set disassemble on|off #the same as set $auto_disassemble = 1 | 0
	  </p>
	  
	</li>
	
	<li>
	  <h6>info X</h6>
	  <p>
	    Description : show the infomation of given item
	    Example :
	    info r #check out current registers
	    info registers
	    info program
	    where        #show where I am
	    info break  # show all break points
	    info cpu
	    info eflags
	    info tab #show paging address translation
	    info device #show the state of specified device

	  </p>
	</li>
	<li>
	  <h6>print-stack</h6>
	  <p>
	    Description : print current stack
	  </p>
	</li>
	<li>
	  <h6>set $REG=VAL</h6>
	  <p>
	    Description : change value of REG.REG can be e([abcd]x|[sb]p|[sd]i).Unchangeable:eflags,cs,ss,ds,es,fs,gs
	    Example :
	    set $eax=0x85
	  </p>
	</li>
	
	<li>
	  <h6>set_cpu</h6>
	  <p>
	    Description :
	  </p>
	</li>
	
	<li>
	  <h6>dump_cpu</h6>
	  <p>
	    Description : show the registers and status of CPU
	  </p>
	  
	</li>
	<li>
	  <h6>lb ADDR</h6>
	  <p>
	    Description : set the break point using <em>linear address</em>
	    Abbrevation : lbreak
	  </p>
	  
	</li>
	<li>
	  <h6>pb</h6>
	  <p>
	    Description : break at a physical address
	    Abbrevation : pbreak
	  </p>
	</li>
	
	<li>
	  <h6>b ADDR</h6>
	  <p>
	    Description : break at ADDR
	  </p>
	</li>
	<li>
	  <h6>x|xp /LEN[bhwg][xduot] ADDR</h6>
	  <p>
	    Description : dump the LEN bytes from ADDR.xp for physical address.It's just the same with GDB x command
	    
	  </p>
	</li>
	
	<li>
	  <h6>n</h6>
	  <p>
	    Description : next instruction
	  </p>
	</li>
	<li>
	  <h6>s N</h6>
	  <p>
	    Description : step to next instruction or more
	    Abbrevation : step
	    Example :
	    s #next instruction
	    s 4   #next 4 instructions
	  </p>
	</li>
	<li>
	  <h6></h6>
	  <p>
	    Description :
	  </p>
	</li>
	<li>
	  <h6>si [count]</h6>
	  <p>
	    Description : abbre. for stepi
	    Example:
	    next $count instructions

	  </p>
	</li>
	<li>
	  <h6>q</h6>
	  <p>
	    Description : quit the debugger
	    Abbrevation : quit
	  </p>
	</li>
	<li>
	  <h6>Othes commands</h6>
	  <p>
	    Description :
	    Example :
	    ptime #current time
	    sb DELTA #insert a time break point "DELTA" instructions into the future.DELTA is a 64-bit long integer,such as 1000L
	    sba TIME #insert a time break point at TIME.
	    modebp #Toggles CPU mode switch breakpoint
	    show [string] # string is [mode|int|call|ret|off|dbg-all|dbg-done].Show messages when the condition meets.

	  </p>
	</li>
	
      </ul>
    </li>
    
  </ul>
</section>
<section id="8_grub">
  <h2>Using Grub to Boot Up Images</h2>
  <ul>
    <li>
      <h4>Refereces</h4>
      <a href="http://wiki.ubuntu.com.cn/GRUB%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B">A Guide to Grub in Chinese</a>
      
    </li>
    <li>
      <h4>Install Grub in a disk image file</h4>
      <ul>
	<li>
	  <h6>Create a Hard Disk Image File & Install Grub2</h6>
	  <p>
	    $ dd if=/dev/zero of=grub2.img bs=512c count=$((2*1024*150)
	    $ # create an image with 150MB disk size
	    $ sudo losetup /dev/loop0 grub2.img
	    $ sudo mkfs.ext4 /dev/loop0
	    $ mkdir TMP
	    $ sudo mount /dev/loop0 TMP
	    $ grub2-install  --boot-directory=TMP/boot /dev/loop0 --verbose --force
	    $ sudo umount TMP && rmdir TMP
	</li>
	<li>
	  <h6>Use Bochs to Start the Image</h6>
	  <p>
	    We need to create a 'bochsrc' file to start that image.The file content may look as following:
	    (filename:bochsrc)
	    megs:30

	    romimage: file=$BXSHARE/BIOS-bochs-latest
	    vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
	    vga: extension=vbe, update_freq=15


	    boot :disk
	    ata0-master: type=disk, path=grub2.img, translation=none

	    log :out.txt
	    mouse :enabled=0
	    #END
	    Then we start is 'bochs -f bochsrc -q'
	  </p>
	</li>
	<li>
	  <h4>Grub Commands</h4>
	</li>
	<li>
	  <h4>Examples Startup</h4>
	  <ul>
	    <li>
	      <h6>Start Linux</h6>
	    </li>
	    <li>
	      <h6>Start LiveCD such as Fedora & Ubunut</h6>
	    </li>
	    <li>
	      <h6>Start Windows 7 & later</h6>
	    </li>
	    <li>
	      <h6>Start an Inside-image System</h6>
	    </li>
	    
	  </ul>
	  
	</li>
	
	
	
      </ul>
      
    </li>
  </ul>
  
</section>
<section id="9_make">
  <h2>GNU Make</h2>
  <ul>
    <li>
      <h4>References</h4>
      <a href="http://www.gnu.org/software/make/manual/make.html">GNU Make Official Site</a>
    </li>
    <li>
      <h4>Main Constructure of Makefile : 5 Parts</h4>
      <p>
	<i>explicit rules</i>
	<i>implicit rules</i>
      <p>
	Based on names
      </p>
      
	<i>variable definitions</i>
	<i>directives</i>
      <p>
	The directives is for make itself.Containing 3 types:
	Reading another Makefile
	Deciding(based on the variables' value) whether to use or ignorea part of the Makefile
	Defining a variable from a verbatim string containing multiple lines
      </p>
      
	<i>comments</i>
      <p>
	Use '#' to define a one-line of multiple-line comments.But do not use '#' in function call or variable references where it will be treated literally.
	Comments in a recipe will be passed to Shell
      </p>
      
      </p>
      
    </li>
    
      <li>
	<h4>Implicit Rules</h4>
	<ul>
	  <li>
	    <h6>'.c'  --to  '.o' always indicate to use 'cc -c $.c $.o'</h6>
	    <p>
	      Example:
	          main.o : defs.h
	          kbd.o : defs.h command.h
	      Note that the recipes are ommited because the Implicit Rules.
	      Example 2:
	          main.o kbd.o files.o : command.h
	          display.o insert.o files.o : buffer.h
	      Note that we group multi object target into one,and just place a prerequisite after them.Each object target may appear more than once.
	    </p>
	  </li>
	  <li>
	    <h6>TARGET :: #no any prerequisite</h6>
	    <p>
	      Description : any target with Double-Colon,a recipe and without any prerequisite will always be remade every time when make runs.<br/>
	    </p>
	  </li>
	  <li>
	    <h6>% : force</h6>
	    <p>
	      Description : this is a match-anything rule if a target not is not found.However , to avoid use of implicit rule, you must add a target(say,'force' here).And 'force' must be defined.<br/>
	    </p>
	  </li>
	  
	  <li>
	    <h6></h6>
	    <p>
	      Example:
	    </p>
	  </li>
	  <li>
	    <h6> -CMD ARGS</h6>
	    <p>
	      Example:
	          .PHONY: clean
	          clean:
	              - rm edit $(objects)
	      The prefix '-' causes make to continue in spite of erros from rm.
	    </p>
	  </li>
	  <li>
	    <h6>Special Variables</h6>
	    <p>$&lt; : the first prerequisite </p>
	    <p>$^ : all the prerequisites without repetitions</p>
	    <p>$+ : all the prerequisites may be with repetitions</p>
		  
		  
	  </li>
	  <li>
	    <h6>The form of Rules</h6>
	    <p> FORM1 : <br/>
	      targets : prerequisities <br/>
	      &amp;&amp;&amp;&amp; recipe <br/>
	      ... <br/>
	    </p>
	    <p>FORM 2 : <br/>
	      targets : prerequisities ; recipes<br/>
	      ...<br/>
	    </p>
	  </li>
	  <li>
	    <h6>Wildcards Expansion</h6>
	    <p>Wildcards do not expand when you define a variable,but expand when you use it as <em>target</em> or <em>prerequisities</em>
	    </p>
	    <p>For example:<br/>
	      objects = *.o  <br/>
	      $(objects) : ... <br/>
	    </p>
	  </li>
	  
	    
	  
	</ul>
	

      <li>

	<h6>Spliting long line</h6>

	<p>
	      Description : the syntax of make is based on single line.A carrige key means the end of a statement.To avoid your newline making the end of the statement,simply add a backslash(\) before the carriage. <br />
	      Example:

	</p>
	  </li>
	  <li>
	    <h6>the Name of Makefile:GNUmakefile, makefile, Makefile</h6>
	    <p>
	      Description : make defaultly search these file in this order to read the rules. <br/>
	      You can override this rule by given option '-f FILE' or '--file FILE'. If multiple files are given,then they're firstly concatenated together in the order specified and then processed as one file.<br/>
	    </p>
	  </li>
	  <li>
	    <h6></h6>
	    <p>
	      Description : 
	      Example:
	    </p>
	  </li>
	  <li>
	    <h6>Including Other Files</h6>
	    <p>
	      Description : the directive 'include' tells Make to include other files.The first character must not be TAB.<br/>
	      The directory to search these files are specified by option '-I/--include-dir DIRECTORY'. <br/>
	      Example: <br/>
	          include foo *.mk $(bar) <br/>
	      Example 2: <br/>
	          Another use of include is sharing a variable set in different Makefiles.<br/>
	      Example 3:<br/>
	          You can use '-'(a slash) to ignore the error by that directive.
	          -include filenames...

	    </p>
	  </li>
    <li>
      <h4>How <i>make</i> Reads a Makefile</h4>
      <p>
	<h6>Description</h6>
	<i>make</i> does its work in two phases.Firstly it internalizes all the variables,rules,dependencies.Then it uses the rules setup in the first step to determine which files to be rebuilt.<br/>
	Remember that unless directived,make will only expand variables in the first phase.<br/>
	The special derective .SECONDEXPANSION(just for a target,not for all) will perform the secondary expansion.<br/>
      </p>
	<h6>Example</h6>
	<p>
	  .SECONDEXPANSION:<br/>
	  ONEVAR = onefile<br/>
	  TWOVAR = twofile<br/>
	  myfie : $(ONEVAR) $$(TWOVAR) <br/>
	  ------</br>
	  $(ONEVAR) is expanded in the first phase,to be onefile.And $$(TWOVAR) is expanded to $(TWOVAR).But there is another expansion in the second expansion.At the second expansion,$(TWOVAR) is expanded to 'twofile'.So the last rule of myfile is 'onefile twofile'.<br/>
	</p>
	<h6>Example 2:expect value until its dependecies are confirmed</h6>
      <p>
	.SECONDEXPANSION:<br/>
	VAR = top <br/>
	onefile : $(VAR) <br/>
	twofile : $$(VAR) <br/>
	VAR = bottom <br/>
	------ <br/>
	VAR is confirmed to be 'bottom' in the first phase,then it is used to determine the value of $(VAR) in the secondary expansion,which is expanded to 'bottom'.<br/>
	The last result is 'twofile : bottom'.<br/>
	One thing needed to be remember is <em>all recipes</em> are determined to be executed or not only in the second phase,so for them there is just one change to expand variables.<br/>
	.SECONDEXPANSION:<br/>
	VAR = zz<br/>
	debug : $$(VAR)<br/>
	    echo $$(VAR)<br/>
	zz :<br/>
	----It will say '/bin/bash VAR ,command not found'.Because the command is expanded to 'echo $(VAR)' then passed to shell,where '$(VAR)' means execute a shell command,which is absolutely unexpected.<br/>
     </p>
      
	
    </li>
    
	  
	  
	  
	 

    <li>
      <h2>Recipe Syntax</h2>


      <h4>Execution</h4>
      <p>Recipes are always interpreted by /bin/sh unless the Makefile specifies a different one.</p>

      <h4>Syntax</h4>
      <p>Each line of a recipe is executed by a single subshell.To avoid this, you can either join them into one line using '\' or use '.ONESHELL'</p>

      <h4>Using variables in recipe</h4>
      <p>The variables are expanded only after a target is out-of-date hence need to update.And those which does not need to update will nevere be expaned.</p>
      <p>Simplely, $ prefix indicates a <i>make</i> variable,while $$ prefix a <i>shell</i> variable</p>
      <p>For example</p>
      <p>for i in one two three;do \<br/>
	echo $i;\<br/>
	done</br>
      </p>
      <p>This will not work,because i is refered as a make variable,whose expansion is ''(null string).So the actually value is 'echo '.</p>
      <p>For shell, make acts like a macro expander.</p>

      <h4>Specific Variables for Shell</h4>
      <p>They are SHELL and .SHELLFLAGS</p>
      <p>For example :<br/>
	.ONESHELL:<br/>
	SHELL = /usr/bin/perl <br/>
	.SHELLFLAGS = -e <br/>
	show : <br/>
	    echo yes<br/>
	------NOTE that the '.' preceeding the '.SHELLFLAGS'<br/>
      </p>
      
      <h4>Communicating Variables to a Sub-<i>make</i></h4>
      <p>Variables can be passed to sub-make , unless they are exported and the option -e is present.
      </p>
      <p>The environment variable and the command line variables are automatically exported</p>
      <p>Export and Unexport syntax are as follows:<br/>
	export variable...<br/>
	export variable=value<br/>
	export variable := value<br/>
	export #this command normally exports all variables<br/>
	unexport variable<br/>
      </p>
   </li>
    <li>
      <h2>Using Variables</h2>


      <h4>Variable Names</h4>
      <p>Variable names are case-sensitive</p>
      <p>Foo,FOO,fOo are not the same variables</p>
      
      <h4>Variable Substitution</h4>
      <p>Use either '${foo}' or '$(foo)' to reference a variables's value</p>

      <h4>Two Flavors of Variables</h4>
      <p>'=' or 'define' will cause a variable find the original value(not only the reference) in the first phase.Thus it may cause performace problems.</p>
      <!--structures makes an editing line context-free-->
      <p>For example:<br/>
	foo = $(bar) <br/>
	bar = $(ugh) <br/>
	ugh = Huh? <br/>
	---The eventaul value of foo is 'Huh?'<br/>
      </p>
      
      
      <p>':='(or equivalent as '::=') will just reference to the last value of a variable or '' if undefined ever</p>
      <p>For example:<br/>
	x := foo
	y := $(x) bar
	x := later
	---The actul value of y is 'foo bar',pointing to the last value of x,not the eventual value of it.<br/>
      </p>

      <h4>User $(shell ...) to substitue execution result</h4>
      <p>
      </p>

      <h4>?= Operator</h4>
      <p> FOO ?= bar </p>
      <p>The assignment happens only if FOO has never been defined.</p>

      <h4>Variable Substitution</h4>
      <p> foo := a.o b.o c.o <br/>
	bar := $(foo:.o=.c)<br/>
	----This replaces all .o in $(foo) to .c<br/>
	It's just an abbreviation for use of the <em>patsubst</em> expansion function.<br/>
      </p>

      <h4>Nested and Computed Varible Name</h4>
      <p>
	x = y<br/>
	y = z<br/>
	a := $($(x)) <br/>
	----However the nest deepth a $(..) is, the outer $(..) will wait the inner $(...) return and caclate its value.In the example above,a = z.<br/>
	You can use this even more complicately as a enhanced C macro,<br/>
	dirs := $($(a1)_$(df)) <br/>
	It allows you to use even complicated joiner , even function,<br/>
	foo := $($(func) $(bar)) <br/>
      </p>
      <p>
	You can use this feature in recipse
      </p>
      
      
      

    </li>
    <li>
      <h2>String Operating Functions</h2>


      <h4>$(subst substr,replace,str)</h4>

      <h4>$(patsubst patter,replace,text)</h4>

      <h4>$(strip string)</h4>
      
    </li>
    
    
    
  </ul>
</section>

<!--last=9-->
<section id="x_others">
  <h2>Other Info</h2>
  <ul>
    <li>
      <h4>How to 'mount hard disk image file(.img) as a regular directory in Linux?</h4>
      <!--When I edit these things,it's like that I am working on a stream,the stream that let you put a word first ,then a tag,then a href,and at this moment, you go to other places to find that href and return,the stream waits for you and then go on.You are not necessary in a tense status.
	  How nice a thing!How nice the feeling!
	-->
      <p>

	The main reference is <a href="http://wiki.osdev.org/Loopback_Device#Floppy_Disk_Images_With_FAT12">HERE</a>
	The very thing you need to remenber is when you 'mount a floppy image,it's not needed to specify it's partition,because it has only on partition.But if you want to mount a hard disk image,you must specify which partition to mount.
	The specific partition is denoted by using 'losetup -o $START $LOOPDEV'
	This losetup command will create a 'device' to represent part of the file you specified.Such device is called loop device,like a loop address 127.0.0.1.
      </p>
    </li>

    <li>
      <h4>Bash String Operation</h4>
      <p>
	${var-DEFAULT}  -- If var is not set,then use DEFAULT as value<br/>
	${var:-DEFAULT} -- if var is not set or is null,then ...<br/>
	${var=DEFAULT} -- If var is not set,then user DEFAULT as var's value
	${var:=DEFAULT} -- ...
	${var?ERROR_MSG}  -- If var not set,print ERROR_MSG
	${var:?ERROR_MSG} -- ...
	${#str}  -- get length of str
	${str:position}  -- get position of char array(string also)
	${str:position:len} -- start from position,get str with length len<br/>
	${str#substr} -- return str with deleted shortest substr from head,str keep unchanged<br/>
	${str##substr} -- same with ${str#substr},but try delete as long as possible <br/>
	${str%substr} -- similarly,but start from the end of str <br/>
	${str%%substr} -- ...
	${str/substr/replace} -- find and replace first <br/>
	${str//substr/replace} -- find and replace all <br/>
	${str/#substr/replace} -- only prefix<br/>
	${str/%substr/replace} -- only suffix<br/>
	#Above all,substr could be regex.
	${arr[@|n]} -- ... <br/>
	arr=([c]=d [x]=y)  -- defines dict array <br/>
	${arr[@]:1:2} -- ..
	${arr[@]/X/Y}  -- replace X in arr with Y <br/>
	for i in ${arr[@]};do ...;done -- Operate array <br/>
	
	
      </p>
      
  </ul>
</section>

</html>
